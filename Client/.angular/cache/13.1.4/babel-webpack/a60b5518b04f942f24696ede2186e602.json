{"ast":null,"code":"var XMLHttpRequest = require('./lib/XMLHttpRequest');\n\nmodule.exports = IPFS;\n/**\n * The varructor object\n * @param {Object} `provider` the provider object\n * @return {Object} `ipfs` returns an IPFS instance\n * @throws if the `new` flag is not used\n */\n\nfunction IPFS(provider) {\n  if (!(this instanceof IPFS)) {\n    throw new Error('[ipfs-mini] IPFS instance must be instantiated with \"new\" flag (e.g. var ipfs = new IPFS(\"http://localhost:8545\");).');\n  }\n\n  var self = this;\n  self.setProvider(provider || {});\n}\n/**\n * No operation method\n */\n\n\nfunction noop() {}\n\nfunction newPromise(val) {\n  return new Promise(val);\n}\n\nfunction noopPromise(val) {\n  val(noop, noop);\n}\n/**\n * Sets the provider of the IPFS instance\n * @param {Object} `provider` the provider object\n * @throws if the provider object is not an object\n */\n\n\nIPFS.prototype.setProvider = function setProvider(provider) {\n  if (typeof provider !== 'object') {\n    throw new Error(`[ifpsjs] provider must be type Object, got '${typeof provider}'.`);\n  }\n\n  var self = this;\n  var data = self.provider = Object.assign({\n    host: '127.0.0.1',\n    pinning: true,\n    port: '5001',\n    protocol: 'http',\n    base: '/api/v0'\n  }, provider || {});\n  self.requestBase = String(`${data.protocol}://${data.host}:${data.port}${data.base}`);\n};\n/**\n * Sends an async data packet to an IPFS node\n * @param {Object} `opts` the options object\n * @param {Function} `cb` the provider callback\n * @callback returns an error if any, or the data from IPFS\n */\n\n\nIPFS.prototype.sendAsync = function sendAsync(opts, cb) {\n  var self = this;\n  var request = new XMLHttpRequest(); // eslint-disable-line\n\n  var options = opts || {};\n  return (cb ? noopPromise : newPromise)(function (resolve, reject) {\n    function callback(e, r) {\n      (cb || noop)(e, options.takeHash && r ? r.Hash : r);\n      if (e) return reject(e);\n      if (!e && r) return resolve(options.takeHash ? r.Hash : r);\n    }\n\n    ;\n\n    request.onreadystatechange = function () {\n      if (request.readyState === 4 && request.timeout !== 1) {\n        if (request.status !== 200) {\n          callback(new Error(`[ipfs-mini] status ${request.status}: ${request.responseText}`), null);\n        } else {\n          try {\n            callback(null, options.jsonParse ? JSON.parse(request.responseText) : request.responseText);\n          } catch (jsonError) {\n            callback(new Error(`[ipfs-mini] while parsing data: '${String(request.responseText)}', error: ${String(jsonError)} with provider: '${self.requestBase}'`, null));\n          }\n        }\n      }\n    };\n\n    try {\n      var pinningURI = self.provider.pinning && opts.uri === '/add' ? '?pin=true' : '';\n\n      if (options.payload) {\n        request.open('POST', `${self.requestBase}${opts.uri}${pinningURI}`);\n      } else {\n        request.open('GET', `${self.requestBase}${opts.uri}${pinningURI}`);\n      }\n\n      if (options.accept) {\n        request.setRequestHeader('accept', options.accept);\n      }\n\n      if (options.payload && options.boundary) {\n        request.setRequestHeader('Content-Type', `multipart/form-data; boundary=${options.boundary}`);\n        request.send(options.payload);\n      } else {\n        request.send();\n      }\n    } catch (err) {\n      callback(err, null);\n    }\n  });\n};\n/**\n * creates a boundary that isn't part of the payload\n */\n\n\nfunction createBoundary(data) {\n  while (true) {\n    var boundary = `----IPFSMini${Math.random() * 100000}.${Math.random() * 100000}`;\n\n    if (data.indexOf(boundary) === -1) {\n      return boundary;\n    }\n  }\n}\n/**\n * Add an string or buffer to IPFS\n * @param {String|Buffer} `input` a single string or buffer\n * @param {Function} `callback` a callback, with (error, ipfsHash String)\n * @callback {String} `ipfsHash` returns an IPFS hash string\n */\n\n\nIPFS.prototype.add = function addData(input, callback) {\n  var data = typeof input === 'object' && input.isBuffer ? input.toString('binary') : input;\n  var boundary = createBoundary(data);\n  var payload = `--${boundary}\\r\\nContent-Disposition: form-data; name=\"path\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n${data}\\r\\n--${boundary}--`;\n  return this.sendAsync({\n    jsonParse: true,\n    accept: 'application/json',\n    uri: '/add',\n    takeHash: true,\n    payload,\n    boundary\n  }, callback);\n};\n/**\n * Add an JSON object to IPFS\n * @param {Object} `jsonData` a single JSON object\n * @param {Function} `callback` a callback, with (error, ipfsHash String)\n * @callback {String} `ipfsHash` returns an IPFS hash string\n */\n\n\nIPFS.prototype.addJSON = function addJson(jsonData, callback) {\n  var self = this;\n  return self.add(JSON.stringify(jsonData), callback);\n};\n/**\n * Get an object stat `/object/stat` for an IPFS hash\n * @param {String} `ipfsHash` a single IPFS hash String\n * @param {Function} `callback` a callback, with (error, stats Object)\n * @callback {Object} `stats` returns the stats object for that IPFS hash\n */\n\n\nIPFS.prototype.stat = function cat(ipfsHash, callback) {\n  var self = this;\n  return self.sendAsync({\n    jsonParse: true,\n    uri: `/object/stat/${ipfsHash}`\n  }, callback);\n};\n/**\n * Get the data from an IPFS hash\n * @param {String} `ipfsHash` a single IPFS hash String\n * @param {Function} `callback` a callback, with (error, stats Object)\n * @callback {String} `data` returns the output data\n */\n\n\nIPFS.prototype.cat = function cat(ipfsHash, callback) {\n  var self = this;\n  return self.sendAsync({\n    uri: `/cat/${ipfsHash}`\n  }, callback);\n};\n/**\n * Get the data from an IPFS hash that is a JSON object\n * @param {String} `ipfsHash` a single IPFS hash String\n * @param {Function} `callback` a callback, with (error, json Object)\n * @callback {Object} `data` returns the output data JSON object\n */\n\n\nIPFS.prototype.catJSON = function catJSON(ipfsHash, callback) {\n  var self = this;\n  return self.sendAsync({\n    uri: `/cat/${ipfsHash}`,\n    jsonParse: true\n  }, callback);\n};","map":{"version":3,"sources":["/Users/nani/Desktop/EHR-2.0/Client/node_modules/ipfs-mini/src/index.js"],"names":["XMLHttpRequest","require","module","exports","IPFS","provider","Error","self","setProvider","noop","newPromise","val","Promise","noopPromise","prototype","data","Object","assign","host","pinning","port","protocol","base","requestBase","String","sendAsync","opts","cb","request","options","resolve","reject","callback","e","r","takeHash","Hash","onreadystatechange","readyState","timeout","status","responseText","jsonParse","JSON","parse","jsonError","pinningURI","uri","payload","open","accept","setRequestHeader","boundary","send","err","createBoundary","Math","random","indexOf","add","addData","input","isBuffer","toString","addJSON","addJson","jsonData","stringify","stat","cat","ipfsHash","catJSON"],"mappings":"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","sourcesContent":["var XMLHttpRequest = require('./lib/XMLHttpRequest');\n\nmodule.exports = IPFS;\n\n/**\n * The varructor object\n * @param {Object} `provider` the provider object\n * @return {Object} `ipfs` returns an IPFS instance\n * @throws if the `new` flag is not used\n */\nfunction IPFS(provider) {\n  if (!(this instanceof IPFS)) { throw new Error('[ipfs-mini] IPFS instance must be instantiated with \"new\" flag (e.g. var ipfs = new IPFS(\"http://localhost:8545\");).'); }\n\n  var self = this;\n  self.setProvider(provider || {});\n}\n\n/**\n * No operation method\n */\nfunction noop() {}\nfunction newPromise(val) { return new Promise(val); }\nfunction noopPromise(val) { val(noop, noop); }\n\n/**\n * Sets the provider of the IPFS instance\n * @param {Object} `provider` the provider object\n * @throws if the provider object is not an object\n */\nIPFS.prototype.setProvider = function setProvider(provider) {\n  if (typeof provider !== 'object') { throw new Error(`[ifpsjs] provider must be type Object, got '${typeof provider}'.`); }\n  var self = this;\n  var data = self.provider = Object.assign({\n    host: '127.0.0.1',\n    pinning: true,\n    port: '5001',\n    protocol: 'http',\n    base: '/api/v0' }, provider || {});\n  self.requestBase = String(`${data.protocol}://${data.host}:${data.port}${data.base}`);\n};\n\n/**\n * Sends an async data packet to an IPFS node\n * @param {Object} `opts` the options object\n * @param {Function} `cb` the provider callback\n * @callback returns an error if any, or the data from IPFS\n */\nIPFS.prototype.sendAsync = function sendAsync(opts, cb) {\n  var self = this;\n  var request = new XMLHttpRequest(); // eslint-disable-line\n  var options = opts || {};\n\n  return (cb ? noopPromise : newPromise)(function (resolve, reject) {\n    function callback(e, r){\n      (cb || noop)(e, options.takeHash && r ? r.Hash : r);\n      if (e) return reject(e);\n      if (!e && r) return resolve(options.takeHash ? r.Hash : r);\n    };\n\n    request.onreadystatechange = function () {\n      if (request.readyState === 4 && request.timeout !== 1) {\n        if (request.status !== 200) {\n          callback(new Error(`[ipfs-mini] status ${request.status}: ${request.responseText}`), null);\n        } else {\n          try {\n            callback(null, (options.jsonParse ? JSON.parse(request.responseText) : request.responseText));\n          } catch (jsonError) {\n            callback(new Error(`[ipfs-mini] while parsing data: '${String(request.responseText)}', error: ${String(jsonError)} with provider: '${self.requestBase}'`, null));\n          }\n        }\n      }\n    };\n\n    try {\n      var pinningURI = self.provider.pinning && opts.uri === '/add' ? '?pin=true' : '';\n\n      if (options.payload) {\n        request.open('POST', `${self.requestBase}${opts.uri}${pinningURI}`);\n      } else {\n        request.open('GET', `${self.requestBase}${opts.uri}${pinningURI}`);\n      }\n\n      if (options.accept) {\n        request.setRequestHeader('accept', options.accept);\n      }\n\n      if (options.payload && options.boundary) {\n        request.setRequestHeader('Content-Type', `multipart/form-data; boundary=${options.boundary}`);\n        request.send(options.payload);\n      } else {\n        request.send();\n      }\n    } catch (err) {\n      callback(err, null);\n    }\n  });\n};\n\n/**\n * creates a boundary that isn't part of the payload\n */\nfunction createBoundary(data) {\n  while (true) {\n    var boundary = `----IPFSMini${Math.random() * 100000}.${Math.random() * 100000}`;\n    if (data.indexOf(boundary) === -1) {\n      return boundary;\n    }\n  }\n}\n\n/**\n * Add an string or buffer to IPFS\n * @param {String|Buffer} `input` a single string or buffer\n * @param {Function} `callback` a callback, with (error, ipfsHash String)\n * @callback {String} `ipfsHash` returns an IPFS hash string\n */\nIPFS.prototype.add = function addData(input, callback) {\n  var data = ((typeof input === 'object' && input.isBuffer) ? input.toString('binary') : input);\n  var boundary = createBoundary(data);\n  var payload = `--${boundary}\\r\\nContent-Disposition: form-data; name=\"path\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n${data}\\r\\n--${boundary}--`;\n\n  return this.sendAsync({\n    jsonParse: true,\n    accept: 'application/json',\n    uri: '/add',\n    takeHash: true,\n    payload, boundary,\n  }, callback);\n};\n\n/**\n * Add an JSON object to IPFS\n * @param {Object} `jsonData` a single JSON object\n * @param {Function} `callback` a callback, with (error, ipfsHash String)\n * @callback {String} `ipfsHash` returns an IPFS hash string\n */\nIPFS.prototype.addJSON = function addJson(jsonData, callback) {\n  var self = this;\n  return self.add(JSON.stringify(jsonData), callback);\n};\n\n/**\n * Get an object stat `/object/stat` for an IPFS hash\n * @param {String} `ipfsHash` a single IPFS hash String\n * @param {Function} `callback` a callback, with (error, stats Object)\n * @callback {Object} `stats` returns the stats object for that IPFS hash\n */\nIPFS.prototype.stat = function cat(ipfsHash, callback) {\n  var self = this;\n  return self.sendAsync({ jsonParse: true, uri: `/object/stat/${ipfsHash}` }, callback);\n};\n\n/**\n * Get the data from an IPFS hash\n * @param {String} `ipfsHash` a single IPFS hash String\n * @param {Function} `callback` a callback, with (error, stats Object)\n * @callback {String} `data` returns the output data\n */\nIPFS.prototype.cat = function cat(ipfsHash, callback) {\n  var self = this;\n  return self.sendAsync({ uri: `/cat/${ipfsHash}` }, callback);\n};\n\n/**\n * Get the data from an IPFS hash that is a JSON object\n * @param {String} `ipfsHash` a single IPFS hash String\n * @param {Function} `callback` a callback, with (error, json Object)\n * @callback {Object} `data` returns the output data JSON object\n */\nIPFS.prototype.catJSON = function catJSON(ipfsHash, callback) {\n  var self = this;\n  return self.sendAsync({ uri: `/cat/${ipfsHash}`, jsonParse: true }, callback);\n};\n"]},"metadata":{},"sourceType":"script"}